{"noir_version":"0.31.0+540bef3597bd3e5775c83ec2ee3c0d4463084b4c","hash":12702600495587027788,"abi":{"parameters":[{"name":"password","type":{"kind":"field"},"visibility":"private"},{"name":"hash_password","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"25":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\nuse crate::hash::poseidon::PoseidonConfig;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(\n        consts::x5_2_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(\n        consts::x5_3_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(\n        consts::x5_4_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(\n        consts::x5_5_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(\n        consts::x5_6_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(\n        consts::x5_7_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(\n        consts::x5_8_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(\n        consts::x5_9_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(\n        consts::x5_10_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(\n        consts::x5_11_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(\n        consts::x5_12_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(\n        consts::x5_13_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(\n        consts::x5_14_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(\n        consts::x5_15_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(\n        consts::x5_16_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(\n        consts::x5_17_config(),\n        state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"26":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\nmod perm;\nmod consts;\n\nuse crate::hash::poseidon::{PoseidonConfig, absorb};\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of §3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\n#[no_predicates]\npub fn sponge<N>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"27":{"source":"mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::field::modulus_num_bits;\nuse crate::hash::Hasher;\nuse crate::default::Default;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\nstruct PoseidonConfig<T, N, X> { \n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n     // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<T, N, X>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X]\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N);\n    assert_eq(t, T);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<T, N, X>(pos_conf: PoseidonConfig<T, N, X>, mut state: [Field; T]) -> [Field; T] {\n    let PoseidonConfig {t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } = pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf/2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf/2+1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<N>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<T, N, X, O>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O] // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i+1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<O>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\n// Check security of sponge instantiation\nfn check_security(rate: Field, width: Field, security: Field) -> bool {\n    let n = modulus_num_bits();\n\n    ((n - 1) as Field * (width - rate) / 2) as u8 > security as u8\n}\n\nstruct PoseidonHasher{\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        } \n        if len == 2 {\n            result = bn254::hash_2([self._state[0],self._state[1]]);\n        } \n        if len == 3 {\n            result = bn254::hash_3([self._state[0],self._state[1],self._state[2]]);\n        } \n        if len == 4 {\n            result = bn254::hash_4([self._state[0],self._state[1],self._state[2],self._state[3]]);\n        } \n        if len == 5 {\n            result = bn254::hash_5([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4]]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5]]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6]]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7]]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8]]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9]]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10]]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11]]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12]]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12], self._state[13]]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12], self._state[13], self._state[14]]);\n        }\n        \n        result\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher{\n    fn default() -> Self{\n        PoseidonHasher{\n            _state: &[],\n        }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a, 0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29, 0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c\n            ];\n            assert_eq(expected, poseidon::bn254::perm::x5_3(state), \"Failed to reproduce output for [0, 1, 2]\");\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465, 0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d, 0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907, 0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e, 0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7\n            ];\n            assert_eq(\n                expected, poseidon::bn254::perm::x5_5(state), \"Failed to reproduce output for [0, 1, 2, 3, 4]\"\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon.nr"},"47":{"source":"// Importe la función hash Poseidon de la biblioteca estándar de Noir\nuse dep::std::hash::poseidon;\n\n// Definir la función principal con tipo de retorno público\nfn main(password: Field, hash_password: Field) -> pub bool {\n    // Calcule el hash de la contraseña ingresada usando Poseidon\n    let computed_hash = std::hash::poseidon::bn254::hash_1([password]);\n\n    // Asegúrese de que el hash calculado coincida con la contraseña hash proporcionada\n    let is_valid = computed_hash == hash_password;\n\n    is_valid\n}\n","path":"/Users/Sebas/Web Projects/zk-auth/zkAuth/src/main.nr"}},"names":["main"]}